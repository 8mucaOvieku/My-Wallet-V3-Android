<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>ComplexMethod:ActivitySummaryItem.kt$NonCustodialActivitySummaryItem$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:TransactionProcessor.kt$TransactionProcessor$private fun ValidationState.toErrorStateOrExecute(pendingTx: PendingTx, secondPassword: String): Completable</ID>
    <ID>ComplexMethod:XlmOnChainTxEngineTest.kt$XlmOnChainTxEngineTest$@Test fun `PendingTx is correctly initialised for exchange address`()</ID>
    <ID>ComplexMethod:XlmOnChainTxEngineTest.kt$XlmOnChainTxEngineTest$@Test fun `PendingTx is correctly initialised for non-exchange address`()</ID>
    <ID>ConstructorParameterNaming:BchAsset.kt$BchAddress$address_: String</ID>
    <ID>ConstructorParameterNaming:XlmAsset.kt$XlmAddress$_address: String</ID>
    <ID>ConstructorParameterNaming:XlmAsset.kt$XlmAddress$_label: String? = null</ID>
    <ID>EmptyCatchBlock:TransactionProcessor.kt$TransactionProcessor${ }</ID>
    <ID>LargeClass:BtcOnChainTxEngineTest.kt$BtcOnChainTxEngineTest : CoincoreTestBase</ID>
    <ID>LongMethod:BchOnChainTxEngineTest.kt$BchOnChainTxEngineTest$@Test fun `update amount modifies the pendingTx correctly for regular fees`()</ID>
    <ID>LongMethod:BtcOnChainTxEngine.kt$BtcOnChainTxEngine$private fun updatePendingTxFromAmount( amount: Money, balance: Money, pendingTx: PendingTx, feesPerKb: Map&lt;FeeLevel, Money>, feeOptions: FeeOptions, coins: List&lt;Utxo> ): PendingTx</ID>
    <ID>LongMethod:BtcOnChainTxEngineTest.kt$BtcOnChainTxEngineTest$@Test fun `changing the custom fee level updates the pendingTx correctly`()</ID>
    <ID>LongMethod:BtcOnChainTxEngineTest.kt$BtcOnChainTxEngineTest$@Test fun `update amount modifies the pendingTx correctly for priority fees`()</ID>
    <ID>LongMethod:BtcOnChainTxEngineTest.kt$BtcOnChainTxEngineTest$@Test fun `update amount modifies the pendingTx correctly for regular fees`()</ID>
    <ID>LongMethod:BtcOnChainTxEngineTest.kt$BtcOnChainTxEngineTest$@Test fun `update fee level from REGULAR to CUSTOM updates the pendingTx correctly`()</ID>
    <ID>LongMethod:BtcOnChainTxEngineTest.kt$BtcOnChainTxEngineTest$@Test fun `update fee level from REGULAR to PRIORITY updates the pendingTx correctly`()</ID>
    <ID>LongMethod:CustodialTradingAccount.kt$CustodialTradingAccount$private fun orderToSummary(order: BuySellOrder): ActivitySummaryItem</ID>
    <ID>LongMethod:Erc20OnChainTxEngineTest.kt$Erc20OnChainTxEngineTest$@Test fun `update fee level from REGULAR to PRIORITY updates the pendingTx correctly`()</ID>
    <ID>LongMethod:EthOnChainTxEngineTest.kt$EthOnChainTxEngineTest$@Test fun `contract target, update fee level from REGULAR to PRIORITY updates the pendingTx correctly`()</ID>
    <ID>LongMethod:EthOnChainTxEngineTest.kt$EthOnChainTxEngineTest$@Test fun `update fee level from REGULAR to PRIORITY updates the pendingTx correctly`()</ID>
    <ID>LongMethod:TxProcessorFactory.kt$TxProcessorFactory$private fun createOnChainProcessor( source: CryptoNonCustodialAccount, target: TransactionTarget, action: AssetAction ): Single&lt;TransactionProcessor></ID>
    <ID>LongMethod:TxProcessorFactory.kt$TxProcessorFactory$private fun createTradingProcessor( source: CustodialTradingAccount, target: TransactionTarget )</ID>
    <ID>LongMethod:WalletConnectTransactionEngineTest.kt$WalletConnectTransactionEngineTest$@Test fun `build confirmations should initialise the correct values`()</ID>
    <ID>LongMethod:XlmAccountActivityTest.kt$XlmAccountActivityTest$@Test fun getXlmTransactionListReceived()</ID>
    <ID>LongMethod:XlmAccountActivityTest.kt$XlmAccountActivityTest$@Test fun getXlmTransactionListSendMatch()</ID>
    <ID>LongMethod:XlmAccountActivityTest.kt$XlmAccountActivityTest$@Test fun getXlmTransactionListSendNoMatch()</ID>
    <ID>LongParameterList:ActivitySummaryItem.kt$FiatActivitySummaryItem$( val currency: FiatCurrency, override val exchangeRates: ExchangeRatesDataManager, override val txId: String, override val timeStampMs: Long, override val value: Money, override val account: FiatAccount, val type: TransactionType, val state: TransactionState, val paymentMethodId: String? )</ID>
    <ID>LongParameterList:AssetTokensBase.kt$CryptoAssetBase$( protected val payloadManager: PayloadDataManager, protected val exchangeRates: ExchangeRatesDataManager, protected val currencyPrefs: CurrencyPrefs, protected val labels: DefaultLabels, protected val custodialManager: CustodialWalletManager, private val interestBalance: InterestBalanceDataManager, protected val tradingBalances: TradingBalanceDataManager, private val pitLinking: PitLinking, protected val remoteLogger: RemoteLogger, protected val identity: UserIdentity, protected val addressResolver: AddressResolver )</ID>
    <ID>LongParameterList:BchAsset.kt$BchAsset$( payloadManager: PayloadDataManager, private val bchDataManager: BchDataManager, custodialManager: CustodialWalletManager, interestBalances: InterestBalanceDataManager, tradingBalances: TradingBalanceDataManager, private val feeDataManager: FeeDataManager, private val sendDataManager: SendDataManager, exchangeRates: ExchangeRatesDataManager, currencyPrefs: CurrencyPrefs, labels: DefaultLabels, pitLinking: PitLinking, remoteLogger: RemoteLogger, private val walletPreferences: WalletStatus, private val beNotifyUpdate: BackendNotificationUpdater, identity: UserIdentity, addressResolver: IdentityAddressResolver )</ID>
    <ID>LongParameterList:BchCryptoWalletAccount.kt$BchCryptoWalletAccount$( payloadManager: PayloadDataManager, private val bchManager: BchDataManager, // Used to lookup the account in payloadDataManager to fetch receive address private val addressIndex: Int, override val exchangeRates: ExchangeRatesDataManager, private val feeDataManager: FeeDataManager, private val sendDataManager: SendDataManager, private val internalAccount: GenericMetadataAccount, private val walletPreferences: WalletStatus, private val custodialWalletManager: CustodialWalletManager, private val refreshTrigger: AccountRefreshTrigger, identity: UserIdentity, override val addressResolver: AddressResolver )</ID>
    <ID>LongParameterList:BchCryptoWalletAccount.kt$BchCryptoWalletAccount.Companion$( payloadManager: PayloadDataManager, jsonAccount: GenericMetadataAccount, bchManager: BchDataManager, addressIndex: Int, exchangeRates: ExchangeRatesDataManager, feeDataManager: FeeDataManager, sendDataManager: SendDataManager, walletPreferences: WalletStatus, custodialWalletManager: CustodialWalletManager, refreshTrigger: AccountRefreshTrigger, identity: UserIdentity, addressResolver: AddressResolver )</ID>
    <ID>LongParameterList:BchOnChainTxEngine.kt$BchOnChainTxEngine$( private val bchDataManager: BchDataManager, private val payloadDataManager: PayloadDataManager, private val sendDataManager: SendDataManager, private val feeManager: FeeDataManager, walletPreferences: WalletStatus, requireSecondPassword: Boolean, resolvedAddress: Single&lt;String> )</ID>
    <ID>LongParameterList:BtcAsset.kt$BtcAsset$( payloadManager: PayloadDataManager, private val sendDataManager: SendDataManager, private val feeDataManager: FeeDataManager, private val coinsWebsocket: CoinsWebSocketInterface, custodialManager: CustodialWalletManager, interestBalances: InterestBalanceDataManager, tradingBalances: TradingBalanceDataManager, exchangeRates: ExchangeRatesDataManager, currencyPrefs: CurrencyPrefs, labels: DefaultLabels, pitLinking: PitLinking, remoteLogger: RemoteLogger, private val walletPreferences: WalletStatus, private val notificationUpdater: BackendNotificationUpdater, identity: UserIdentity, addressResolver: IdentityAddressResolver )</ID>
    <ID>LongParameterList:BtcCryptoWalletAccount.kt$BtcCryptoWalletAccount$( payloadManager: PayloadDataManager, private val sendDataManager: SendDataManager, private val feeDataManager: FeeDataManager, // Used to lookup the account in payloadDataManager to fetch receive address private val hdAccountIndex: Int, override val exchangeRates: ExchangeRatesDataManager, private val internalAccount: JsonSerializableAccount, val isHDAccount: Boolean, private val walletPreferences: WalletStatus, private val custodialWalletManager: CustodialWalletManager, private val refreshTrigger: AccountRefreshTrigger, identity: UserIdentity, override val addressResolver: AddressResolver )</ID>
    <ID>LongParameterList:BtcCryptoWalletAccount.kt$BtcCryptoWalletAccount.Companion$( importedAccount: ImportedAddress, payloadManager: PayloadDataManager, sendDataManager: SendDataManager, feeDataManager: FeeDataManager, exchangeRates: ExchangeRatesDataManager, walletPreferences: WalletStatus, custodialWalletManager: CustodialWalletManager, refreshTrigger: AccountRefreshTrigger, identity: UserIdentity, addressResolver: AddressResolver )</ID>
    <ID>LongParameterList:BtcCryptoWalletAccount.kt$BtcCryptoWalletAccount.Companion$( jsonAccount: Account, payloadManager: PayloadDataManager, hdAccountIndex: Int, sendDataManager: SendDataManager, feeDataManager: FeeDataManager, exchangeRates: ExchangeRatesDataManager, walletPreferences: WalletStatus, custodialWalletManager: CustodialWalletManager, refreshTrigger: AccountRefreshTrigger, identity: UserIdentity, addressResolver: AddressResolver )</ID>
    <ID>LongParameterList:BtcOnChainTxEngine.kt$BtcOnChainTxEngine$( amount: Money, balance: Money, pendingTx: PendingTx, feesPerKb: Map&lt;FeeLevel, Money>, feeOptions: FeeOptions, coins: List&lt;Utxo> )</ID>
    <ID>LongParameterList:Coincore.kt$Coincore$( private val assetLoader: AssetLoader, private val assetCatalogue: AssetCatalogueImpl, // TODO: Build an interface on PayloadDataManager/PayloadManager for 'global' crypto calls; second password etc? private val payloadManager: PayloadDataManager, private val txProcessorFactory: TxProcessorFactory, private val defaultLabels: DefaultLabels, private val fiatAsset: Asset, private val currencyPrefs: CurrencyPrefs, private val remoteLogger: RemoteLogger, private val paymentsDataManager: PaymentsDataManager, private val disabledEvmAssets: List&lt;AssetInfo> )</ID>
    <ID>LongParameterList:CustodialTradingAccount.kt$CustodialTradingAccount$( override val currency: AssetInfo, override val label: String, override val exchangeRates: ExchangeRatesDataManager, val custodialWalletManager: CustodialWalletManager, val tradingBalances: TradingBalanceDataManager, val isNoteSupported: Boolean = false, override val isMemoSupported: Boolean = false, private val identity: UserIdentity, override val baseActions: Set&lt;AssetAction> = defaultActions )</ID>
    <ID>LongParameterList:CustodialTradingAccountActionsTest.kt$CustodialTradingAccountActionsTest$( accountBalance: CryptoValue, actionableBalance: CryptoValue, pendingBalance: CryptoValue = CryptoValue.zero(TEST_ASSET), simpleBuy: Boolean, interest: Boolean, supportedFiat: List&lt;FiatCurrency>, custodialAccess: Boolean, buySupported: Boolean )</ID>
    <ID>LongParameterList:DynamicAssetLoader.kt$DynamicAssetLoader$( private val nonCustodialAssets: Set&lt;CryptoAsset>, private val experimentalL1EvmAssets: Set&lt;CryptoCurrency>, private val assetCatalogue: AssetCatalogueImpl, private val payloadManager: PayloadDataManager, private val erc20DataManager: Erc20DataManager, private val feeDataManager: FeeDataManager, private val walletPreferences: WalletStatus, private val custodialManager: CustodialWalletManager, private val exchangeRates: ExchangeRatesDataManager, private val tradingBalances: TradingBalanceDataManager, private val interestBalances: InterestBalanceDataManager, private val currencyPrefs: CurrencyPrefs, private val labels: DefaultLabels, private val pitLinking: PitLinking, private val remoteLogger: RemoteLogger, private val identity: UserIdentity, private val formatUtils: FormatUtilities, private val identityAddressResolver: IdentityAddressResolver, private val ethHotWalletAddressResolver: EthHotWalletAddressResolver, private val layerTwoFeatureFlag: FeatureFlag )</ID>
    <ID>LongParameterList:DynamicOnlyTradingAsset.kt$DynamicOnlyTradingAsset$( override val assetInfo: AssetInfo, payloadManager: PayloadDataManager, custodialManager: CustodialWalletManager, interestBalances: InterestBalanceDataManager, tradingBalances: TradingBalanceDataManager, exchangeRates: ExchangeRatesDataManager, currencyPrefs: CurrencyPrefs, labels: DefaultLabels, pitLinking: PitLinking, remoteLogger: RemoteLogger, identity: UserIdentity, private val addressValidation: String? = null, private val availableActions: Set&lt;AssetAction> = emptySet(), addressResolver: IdentityAddressResolver )</ID>
    <ID>LongParameterList:Erc20ActivitySummaryItem.kt$Erc20ActivitySummaryItem$( override val asset: AssetInfo, private val event: Erc20HistoryEvent, private val accountHash: String, private val erc20DataManager: Erc20DataManager, override val exchangeRates: ExchangeRatesDataManager, lastBlockNumber: BigInteger, override val account: CryptoAccount, override val supportsDescription: Boolean )</ID>
    <ID>LongParameterList:Erc20Asset.kt$Erc20Address$( override val asset: AssetInfo, override val address: String, override val label: String = address, override val isDomain: Boolean = false, override val amount: Money? = null, override val onTxCompleted: (TxResult) -> Completable = { Completable.complete() }, val isContract: Boolean = false )</ID>
    <ID>LongParameterList:Erc20Asset.kt$Erc20Asset$( override val assetInfo: AssetInfo, private val erc20DataManager: Erc20DataManager, private val feeDataManager: FeeDataManager, private val walletPreferences: WalletStatus, payloadManager: PayloadDataManager, custodialManager: CustodialWalletManager, interestBalances: InterestBalanceDataManager, tradingBalances: TradingBalanceDataManager, exchangeRates: ExchangeRatesDataManager, currencyPrefs: CurrencyPrefs, labels: DefaultLabels, pitLinking: PitLinking, remoteLogger: RemoteLogger, identity: UserIdentity, private val availableCustodialActions: Set&lt;AssetAction>, private val availableNonCustodialActions: Set&lt;AssetAction>, private val formatUtils: FormatUtilities, addressResolver: EthHotWalletAddressResolver, private val layerTwoFeatureFlag: FeatureFlag )</ID>
    <ID>LongParameterList:Erc20NonCustodialAccount.kt$Erc20NonCustodialAccount$( payloadManager: PayloadDataManager, asset: AssetInfo, private val erc20DataManager: Erc20DataManager, internal val address: String, private val fees: FeeDataManager, override val label: String, override val exchangeRates: ExchangeRatesDataManager, private val walletPreferences: WalletStatus, private val custodialWalletManager: CustodialWalletManager, override val baseActions: Set&lt;AssetAction>, identity: UserIdentity, override val addressResolver: AddressResolver, override val l1Network: EvmNetwork )</ID>
    <ID>LongParameterList:EthAsset.kt$EthAsset$( payloadManager: PayloadDataManager, private val ethDataManager: EthDataManager, private val feeDataManager: FeeDataManager, private val assetCatalogue: Lazy&lt;AssetCatalogue>, custodialManager: CustodialWalletManager, interestBalances: InterestBalanceDataManager, tradingBalances: TradingBalanceDataManager, exchangeRates: ExchangeRatesDataManager, currencyPrefs: CurrencyPrefs, private val walletPrefs: WalletStatus, private val notificationUpdater: BackendNotificationUpdater, labels: DefaultLabels, pitLinking: PitLinking, remoteLogger: RemoteLogger, identity: UserIdentity, private val formatUtils: FormatUtilities, addressResolver: EthHotWalletAddressResolver, private val layerTwoFeatureFlag: FeatureFlag )</ID>
    <ID>LongParameterList:EthCryptoWalletAccount.kt$EthCryptoWalletAccount$( payloadManager: PayloadDataManager, private val jsonAccount: EthereumAccount, private val ethDataManager: EthDataManager, private val fees: FeeDataManager, private val walletPreferences: WalletStatus, override val exchangeRates: ExchangeRatesDataManager, private val custodialWalletManager: CustodialWalletManager, private val assetCatalogue: AssetCatalogue, identity: UserIdentity, override val addressResolver: AddressResolver, override val l1Network: EvmNetwork )</ID>
    <ID>LongParameterList:EthereumSendTransactionTarget.kt$EthereumSendTransactionTarget$( val dAppAddress: String, val dAppName: String, val dAppLogoURL: String, private val transaction: EthereumJsonRpcTransaction, val method: Method, override val onTxCompleted: (TxResult) -> Completable, override val onTxCancelled: () -> Completable )</ID>
    <ID>LongParameterList:EthereumSignMessageTarget.kt$EthereumSignMessageTarget$( val dAppAddress: String, private val dAppName: String, val dAppLogoUrl: String, val currency: Currency = CryptoCurrency.ETHER, val message: EthSignMessage, override val onTxCompleted: (TxResult) -> Completable, override val onTxCancelled: () -> Completable )</ID>
    <ID>LongParameterList:FiatCustodialAccount.kt$FiatCustodialAccount$( override val label: String, override val currency: FiatCurrency, override val isDefault: Boolean = false, private val tradingBalanceDataManager: TradingBalanceDataManager, private val custodialWalletManager: CustodialWalletManager, private val paymentsDataManager: PaymentsDataManager, private val exchangesRates: ExchangeRatesDataManager )</ID>
    <ID>LongParameterList:L1EvmNonCustodialAccount.kt$L1EvmNonCustodialAccount$( payloadManager: PayloadDataManager, asset: AssetInfo, private val ethDataManager: EthDataManager, private val erc20DataManager: Erc20DataManager, internal val address: String, private val fees: FeeDataManager, override val label: String, override val exchangeRates: ExchangeRatesDataManager, private val walletPreferences: WalletStatus, private val custodialWalletManager: CustodialWalletManager, override val baseActions: Set&lt;AssetAction>, identity: UserIdentity, override val addressResolver: AddressResolver, override val l1Network: EvmNetwork )</ID>
    <ID>LongParameterList:LinkedBankAccount.kt$LinkedBankAccount$( override val label: String, val accountNumber: String, val accountId: String, val accountType: String, override val currency: FiatCurrency, val custodialWalletManager: CustodialWalletManager, val type: PaymentMethodType )</ID>
    <ID>LongParameterList:MaticAsset.kt$MaticAsset$( private val ethDataManager: EthDataManager, private val erc20DataManager: Erc20DataManager, private val feeDataManager: FeeDataManager, private val walletPreferences: WalletStatus, payloadManager: PayloadDataManager, custodialManager: CustodialWalletManager, interestBalances: InterestBalanceDataManager, tradingBalances: TradingBalanceDataManager, exchangeRates: ExchangeRatesDataManager, currencyPrefs: CurrencyPrefs, labels: DefaultLabels, pitLinking: PitLinking, remoteLogger: RemoteLogger, identity: UserIdentity, private val availableNonCustodialActions: Set&lt;AssetAction>, private val formatUtils: FormatUtilities, addressResolver: EthHotWalletAddressResolver, private val layerTwoFeatureFlag: FeatureFlag )</ID>
    <ID>LongParameterList:TestNonCustodialSummaryItem.kt$TestNonCustodialSummaryItem$( override val exchangeRates: ExchangeRatesDataManager = mock(), override val asset: AssetInfo = CryptoCurrency.BTC, override val transactionType: TransactionSummary.TransactionType = TransactionSummary.TransactionType.RECEIVED, override val timeStampMs: Long = 0, override val value: Money = Money.zero(CryptoCurrency.BTC), override val fee: Observable&lt;Money> = Observable.just(Money.zero(CryptoCurrency.BTC)), override val txId: String = "", override val inputsMap: Map&lt;String, CryptoValue> = emptyMap(), override val outputsMap: Map&lt;String, CryptoValue> = emptyMap(), override val description: String? = null, override val confirmations: Int = 0, override val isFeeTransaction: Boolean = false, override val account: CryptoAccount = mock(), override val supportsDescription: Boolean = true )</ID>
    <ID>LongParameterList:TxProcessorFactory.kt$TxProcessorFactory$( private val bitPayManager: BitPayDataManager, private val exchangeRates: ExchangeRatesDataManager, private val walletManager: CustodialWalletManager, private val paymentsDataManager: PaymentsDataManager, private val limitsDataManager: LimitsDataManager, private val interestBalances: InterestBalanceDataManager, private val walletPrefs: WalletStatus, private val ethMessageSigner: EthMessageSigner, private val ethDataManager: EthDataManager, private val bankPartnerCallbackProvider: BankPartnerCallbackProvider, private val quotesEngine: TransferQuotesEngine, private val fees: FeeDataManager, private val analytics: Analytics, private val withdrawLocksRepository: WithdrawLocksRepository, private val userIdentity: UserIdentity )</ID>
    <ID>LongParameterList:XlmAsset.kt$XlmAsset$( payloadManager: PayloadDataManager, private val xlmDataManager: XlmDataManager, private val xlmFeesFetcher: XlmFeesFetcher, private val walletOptionsDataManager: WalletOptionsDataManager, custodialManager: CustodialWalletManager, interestBalances: InterestBalanceDataManager, tradingBalances: TradingBalanceDataManager, exchangeRates: ExchangeRatesDataManager, currencyPrefs: CurrencyPrefs, labels: DefaultLabels, pitLinking: PitLinking, remoteLogger: RemoteLogger, private val walletPreferences: WalletStatus, identity: UserIdentity, addressResolver: IdentityAddressResolver )</ID>
    <ID>LongParameterList:XlmCryptoWalletAccount.kt$XlmCryptoWalletAccount$( payloadManager: PayloadDataManager, private var xlmAccountReference: XlmAccountReference, private val xlmManager: XlmDataManager, override val exchangeRates: ExchangeRatesDataManager, private val xlmFeesFetcher: XlmFeesFetcher, private val walletOptionsDataManager: WalletOptionsDataManager, private val walletPreferences: WalletStatus, private val custodialWalletManager: CustodialWalletManager, identity: UserIdentity, override val addressResolver: AddressResolver )</ID>
    <ID>MagicNumber:BchOnChainTxEngine.kt$BchOnChainTxEngine$1000</ID>
    <ID>MagicNumber:BitpayTxEngine.kt$BitpayTxEngine$1000</ID>
    <ID>MagicNumber:BtcOnChainTxEngine.kt$BtcOnChainTxEngine$1000</ID>
    <ID>MagicNumber:TradingToOnChainTxEngine.kt$TradingToOnChainTxEngine$28</ID>
    <ID>MagicNumber:TransferQuotesEngine.kt$1000</ID>
    <ID>MagicNumber:XlmOnChainTxEngine.kt$XlmOnChainTxEngine$28</ID>
    <ID>MaxLineLength:CryptoAccountBase.kt$CryptoAccountNonCustodialGroup$// We have to remove duplicate AssetActions, we give priority to Available and pick the first as fallback</ID>
    <ID>MaxLineLength:CustodialTradingAccountActionsTest.kt$CustodialTradingAccountActionsTest$fun</ID>
    <ID>MaxLineLength:EthereumJsonRpcTransaction.kt$EthereumJsonRpcTransaction$// gas: QUANTITY - (optional, default: 90000) Integer of the gas provided for the transaction execution. It will return unused gas.</ID>
    <ID>MaxLineLength:EthereumJsonRpcTransaction.kt$EthereumJsonRpcTransaction$// nonce: QUANTITY - (optional) Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce.</ID>
    <ID>MaxLineLength:TransactionProcessor.kt$TxEngine$// Action to be executed once the transaction has been executed, it will have been validated before this is called, so the expectation</ID>
    <ID>MaximumLineLength:com.blockchain.coincore.impl.CustodialTradingAccountActionsTest.kt:264</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.Coincore.kt:199</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.Coincore.kt:201</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.TransactionProcessor.kt:370</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.TransactionProcessor.kt:520</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.TransactionProcessor.kt:522</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.TransactionProcessor.kt:531</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.btc.BtcAsset.kt:182</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.btc.BtcCryptoWalletAccount.kt:170</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.btc.BtcCryptoWalletAccount.kt:172</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.eth.EthOnChainTxEngine.kt:205</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.AccountFilter.kt:33</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.AccountFilter.kt:37</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.AccountFilter.kt:46</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.AccountFilter.kt:50</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.AccountFilter.kt:60</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.AccountFilter.kt:64</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.AccountFilter.kt:73</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.AccountFilter.kt:75</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.txEngine.sell.SellTxEngineBase.kt:89</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.txEngine.swap.SwapTxEngineBase.kt:112</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.txEngine.swap.SwapTxEngineBase.kt:120</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.txEngine.swap.SwapTxEngineBase.kt:162</ID>
    <ID>MultiLineIfElse:com.blockchain.coincore.impl.txEngine.swap.SwapTxEngineBase.kt:170</ID>
    <ID>ReturnCount:Erc20Asset.kt$Erc20Asset$private fun processEip681Format(address: String, label: String?, isDomainAddress: Boolean): Maybe&lt;ReceiveAddress></ID>
    <ID>ReturnCount:PricesInterpolator.kt$PricesInterpolator$fun getRate(amount: Money): Money</ID>
    <ID>SwallowedException:TransactionProcessor.kt$TransactionProcessor$e: IllegalStateException</ID>
    <ID>TooGenericExceptionCaught:BchOnChainTxEngine.kt$BchOnChainTxEngine$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BtcOnChainTxEngine.kt$BtcOnChainTxEngine$e: Exception</ID>
    <ID>TooGenericExceptionThrown:BtcAsset.kt$BtcAsset$throw Exception()</ID>
    <ID>TooGenericExceptionThrown:EthAsset.kt$EthAsset$throw Exception("No ether wallet found")</ID>
    <ID>TooGenericExceptionThrown:EthAsset.kt$EthAsset$throw Exception("No ethereum account found")</ID>
    <ID>TooGenericExceptionThrown:OnChainSellTxEngine.kt$OnChainSellTxEngine$throw Exception("Not supported")</ID>
    <ID>TooGenericExceptionThrown:OnChainSwapTxEngine.kt$OnChainSwapTxEngine$throw Exception("Not supported")</ID>
    <ID>TooManyFunctions:AssetTokensBase.kt$CryptoAssetBase : CryptoAssetAccountRefreshTrigger</ID>
    <ID>TooManyFunctions:BchCryptoWalletAccount.kt$BchCryptoWalletAccount : CryptoNonCustodialAccount</ID>
    <ID>TooManyFunctions:BchOnChainTxEngine.kt$BchOnChainTxEngine : OnChainTxEngineBaseBitPayClientEngine</ID>
    <ID>TooManyFunctions:BitpayTxEngine.kt$BitpayTxEngine : TxEngine</ID>
    <ID>TooManyFunctions:BtcAsset.kt$BtcAsset : CryptoAssetBase</ID>
    <ID>TooManyFunctions:BtcCryptoWalletAccount.kt$BtcCryptoWalletAccount : CryptoNonCustodialAccount</ID>
    <ID>TooManyFunctions:BtcOnChainTxEngine.kt$BtcOnChainTxEngine : OnChainTxEngineBaseBitPayClientEngineKoinComponent</ID>
    <ID>TooManyFunctions:Coincore.kt$Coincore</ID>
    <ID>TooManyFunctions:Erc20OnChainTxEngine.kt$Erc20OnChainTxEngine : OnChainTxEngineBase</ID>
    <ID>TooManyFunctions:EthOnChainTxEngine.kt$EthOnChainTxEngine : OnChainTxEngineBase</ID>
    <ID>TooManyFunctions:FiatDepositTxEngine.kt$FiatDepositTxEngine : TxEngine</ID>
    <ID>TooManyFunctions:InterestDepositOnChainTxEngine.kt$InterestDepositOnChainTxEngine : InterestBaseEngine</ID>
    <ID>TooManyFunctions:InterestDepositTradingEngine.kt$InterestDepositTradingEngine : InterestBaseEngine</ID>
    <ID>TooManyFunctions:InterestWithdrawOnChainTxEngine.kt$InterestWithdrawOnChainTxEngine : InterestBaseEngine</ID>
    <ID>TooManyFunctions:L1EvmOnChainTxEngine.kt$L1EvmOnChainTxEngine : OnChainTxEngineBase</ID>
    <ID>TooManyFunctions:QuotedEngine.kt$QuotedEngine : TxEngine</ID>
    <ID>TooManyFunctions:SellTxEngineBase.kt$SellTxEngineBase : QuotedEngine</ID>
    <ID>TooManyFunctions:SwapTxEngineBase.kt$SwapTxEngineBase : QuotedEngine</ID>
    <ID>TooManyFunctions:TradingToOnChainTxEngine.kt$TradingToOnChainTxEngine : TxEngine</ID>
    <ID>TooManyFunctions:TransactionProcessor.kt$TransactionProcessor : RefreshTrigger</ID>
    <ID>TooManyFunctions:TransactionProcessor.kt$TxEngine : KoinComponent</ID>
    <ID>TooManyFunctions:WalletConnectSignEngine.kt$WalletConnectSignEngine : TxEngine</ID>
    <ID>TooManyFunctions:WalletConnectTransactionEngine.kt$WalletConnectTransactionEngine : TxEngine</ID>
    <ID>TooManyFunctions:XlmOnChainTxEngine.kt$XlmOnChainTxEngine : OnChainTxEngineBase</ID>
    <ID>TopLevelPropertyNaming:CryptoAccountBase.kt$internal const val transactionFetchCount = 50</ID>
    <ID>TopLevelPropertyNaming:CryptoAccountBase.kt$internal const val transactionFetchOffset = 0</ID>
    <ID>TopLevelPropertyNaming:DynamicAssetLoader.kt$// This is a rubbish regex, but it'll do until I'm provided a better one private const val defaultCustodialAddressValidation = "[a-zA-Z0-9]{15,}"</ID>
    <ID>UnusedPrivateMember:BackendNotificationUpdater.kt$NotificationReceiveAddresses$private val coin: String</ID>
    <ID>UnusedPrivateMember:BtcOnChainTxEngineTest.kt$BtcOnChainTxEngineTest.Companion$private const val SOURCE_XPUB = "VALID_BTC_XPUB"</ID>
    <ID>UnusedPrivateMember:EthAsset.kt$EthAsset$private val layerTwoFeatureFlag: FeatureFlag</ID>
    <ID>UnusedPrivateMember:OnChainSellTxEngineTest.kt$OnChainSellTxEngineTest$val kycTiers: KycTiers = mock()</ID>
    <ID>UnusedPrivateMember:OnChainSellTxEngineTest.kt$OnChainSellTxEngineTest.Companion$private val MAX_GOLD_ORDER_ASSET = CryptoValue.fromMajor(SRC_ASSET, 250.toBigDecimal())</ID>
    <ID>UnusedPrivateMember:OnChainSwapEngineTest.kt$OnChainSwapEngineTest.Companion$private val MAX_GOLD_ORDER_ASSET = CryptoValue.fromMajor(SRC_ASSET, 250.toBigDecimal())</ID>
    <ID>UnusedPrivateMember:TradingToTradingSwapTxEngine.kt$TradingToTradingSwapTxEngine.Companion$private val AVAILABLE_FEE_LEVELS = setOf(FeeLevel.None)</ID>
    <ID>UnusedPrivateMember:TxProcessorFactory.kt$TxProcessorFactory$action: AssetAction</ID>
    <ID>UnusedPrivateMember:XlmOnChainTxEngineTest.kt$XlmOnChainTxEngineTest$val v = 100</ID>
    <ID>VariableNaming:BitPayApiException.kt$BitPayApiException$lateinit var _error: String</ID>
    <ID>VariableNaming:BitPayApiException.kt$BitPayApiException$var _httpErrorCode: Int = -1</ID>
  </CurrentIssues>
</SmellBaseline>
